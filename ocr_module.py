{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6101a302-eefe-4635-9880-d41dd0c88e70",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pytesseract\n",
    "\n",
    " \n",
    "pytesseract.pytesseract.tesseract_cmd = r'C:\\Program Files\\Tesseract-OCR\\tesseract.exe'\n",
    "\n",
    "    \n",
    "import cv2\n",
    "import pytesseract\n",
    "import numpy as np\n",
    "from PIL import Image\n",
    "import re\n",
    "from pdf2image import convert_from_path\n",
    "import PyPDF2\n",
    "import io\n",
    "\n",
    "class MedicalReportOCR:\n",
    "    \"\"\"OCR module for extracting text from medical lab reports\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        # Configure Tesseract path if needed\n",
    "        # pytesseract.pytesseract.tesseract_cmd = r'C:\\Program Files\\Tesseract-OCR\\tesseract.exe'\n",
    "        pass\n",
    "    \n",
    "    def preprocess_image(self, image):\n",
    "        \"\"\"\n",
    "        Preprocess image for better OCR accuracy\n",
    "        \n",
    "        Args:\n",
    "            image: PIL Image or numpy array\n",
    "            \n",
    "        Returns:\n",
    "            Preprocessed numpy array\n",
    "        \"\"\"\n",
    "        # Convert PIL to numpy if needed\n",
    "        if isinstance(image, Image.Image):\n",
    "            image = np.array(image)\n",
    "        \n",
    "        # Convert to grayscale\n",
    "        if len(image.shape) == 3:\n",
    "            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n",
    "        else:\n",
    "            gray = image\n",
    "        \n",
    "        # Denoise\n",
    "        denoised = cv2.fastNlMeansDenoising(gray, None, 10, 7, 21)\n",
    "        \n",
    "        # Adaptive thresholding\n",
    "        binary = cv2.adaptiveThreshold(\n",
    "            denoised, 255, \n",
    "            cv2.ADAPTIVE_THRESH_GAUSSIAN_C, \n",
    "            cv2.THRESH_BINARY, 11, 2\n",
    "        )\n",
    "        \n",
    "        # Dilation and erosion to remove noise\n",
    "        kernel = np.ones((1, 1), np.uint8)\n",
    "        processed = cv2.dilate(binary, kernel, iterations=1)\n",
    "        processed = cv2.erode(processed, kernel, iterations=1)\n",
    "        \n",
    "        return processed\n",
    "    \n",
    "    def extract_text_from_image(self, image_path):\n",
    "        \"\"\"\n",
    "        Extract text from image using Tesseract OCR\n",
    "        \n",
    "        Args:\n",
    "            image_path: Path to image file\n",
    "            \n",
    "        Returns:\n",
    "            Extracted text as string\n",
    "        \"\"\"\n",
    "        try:\n",
    "            # Load image\n",
    "            image = Image.open(image_path)\n",
    "            \n",
    "            # Preprocess\n",
    "            processed = self.preprocess_image(image)\n",
    "            \n",
    "            # OCR with custom config\n",
    "            custom_config = r'--oem 3 --psm 6'\n",
    "            text = pytesseract.image_to_string(processed, config=custom_config)\n",
    "            \n",
    "            return text\n",
    "        except Exception as e:\n",
    "            print(f\"Error extracting text from image: {e}\")\n",
    "            return \"\"\n",
    "    \n",
    "    def extract_text_from_pdf(self, pdf_path):\n",
    "        \"\"\"\n",
    "        Extract text from PDF file\n",
    "        \n",
    "        Args:\n",
    "            pdf_path: Path to PDF file\n",
    "            \n",
    "        Returns:\n",
    "            Extracted text as string\n",
    "        \"\"\"\n",
    "        try:\n",
    "            # Try direct text extraction first\n",
    "            with open(pdf_path, 'rb') as file:\n",
    "                pdf_reader = PyPDF2.PdfReader(file)\n",
    "                text = \"\"\n",
    "                for page in pdf_reader.pages:\n",
    "                    text += page.extract_text()\n",
    "            \n",
    "            # If no text found, use OCR\n",
    "            if not text.strip():\n",
    "                images = convert_from_path(pdf_path)\n",
    "                text = \"\"\n",
    "                for image in images:\n",
    "                    processed = self.preprocess_image(image)\n",
    "                    text += pytesseract.image_to_string(processed)\n",
    "            \n",
    "            return text\n",
    "        except Exception as e:\n",
    "            print(f\"Error extracting text from PDF: {e}\")\n",
    "            return \"\"\n",
    "    \n",
    "    def extract_text(self, file_path):\n",
    "        \"\"\"\n",
    "        Extract text from file (auto-detect PDF or Image)\n",
    "        \n",
    "        Args:\n",
    "            file_path: Path to file\n",
    "            \n",
    "        Returns:\n",
    "            Extracted text as string\n",
    "        \"\"\"\n",
    "        file_path = str(file_path).lower()\n",
    "        \n",
    "        if file_path.endswith('.pdf'):\n",
    "            return self.extract_text_from_pdf(file_path)\n",
    "        elif file_path.endswith(('.png', '.jpg', '.jpeg', '.tiff', '.bmp')):\n",
    "            return self.extract_text_from_image(file_path)\n",
    "        else:\n",
    "            raise ValueError(\"Unsupported file format\")\n",
    "\n",
    "\n",
    "class MedicalTextParser:\n",
    "    \"\"\"NLP-based parser for medical lab reports\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        # Define test patterns\n",
    "        self.test_patterns = {\n",
    "            'hemoglobin': [\n",
    "                r'hemoglobin[:\\s]*(\\d+\\.?\\d*)\\s*(g/dl|gm/dl)?',\n",
    "                r'hb[:\\s]*(\\d+\\.?\\d*)\\s*(g/dl|gm/dl)?',\n",
    "                r'hgb[:\\s]*(\\d+\\.?\\d*)\\s*(g/dl|gm/dl)?'\n",
    "            ],\n",
    "            'wbc': [\n",
    "                r'wbc[:\\s]*(\\d+\\.?\\d*)\\s*(×10³/µl|x10\\^3/ul|thou/cumm)?',\n",
    "                r'white blood cell[:\\s]*(\\d+\\.?\\d*)',\n",
    "                r'total\\s*leucocyte\\s*count[:\\s]*(\\d+\\.?\\d*)'\n",
    "            ],\n",
    "            'rbc': [\n",
    "                r'rbc[:\\s]*(\\d+\\.?\\d*)\\s*(mill/cumm|×10⁶/µl)?',\n",
    "                r'red blood cell[:\\s]*(\\d+\\.?\\d*)',\n",
    "                r'total\\s*rbc\\s*count[:\\s]*(\\d+\\.?\\d*)'\n",
    "            ],\n",
    "            'platelets': [\n",
    "                r'platelet[s]?[:\\s]*(\\d+\\.?\\d*)\\s*(×10³/µl|thou/cumm)?',\n",
    "                r'plt[:\\s]*(\\d+\\.?\\d*)'\n",
    "            ],\n",
    "            'glucose': [\n",
    "                r'glucose[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?',\n",
    "                r'blood\\s*sugar[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?',\n",
    "                r'fbs[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?',\n",
    "                r'random\\s*blood\\s*sugar[:\\s]*(\\d+\\.?\\d*)'\n",
    "            ],\n",
    "            'cholesterol': [\n",
    "                r'cholesterol[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?',\n",
    "                r'total\\s*cholesterol[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?'\n",
    "            ],\n",
    "            'hdl': [\n",
    "                r'hdl[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?',\n",
    "                r'hdl\\s*cholesterol[:\\s]*(\\d+\\.?\\d*)'\n",
    "            ],\n",
    "            'ldl': [\n",
    "                r'ldl[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?',\n",
    "                r'ldl\\s*cholesterol[:\\s]*(\\d+\\.?\\d*)'\n",
    "            ],\n",
    "            'triglycerides': [\n",
    "                r'triglyceride[s]?[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?',\n",
    "                r'tg[:\\s]*(\\d+\\.?\\d*)\\s*(mg/dl)?'\n",
    "            ],\n",
    "            'hba1c': [\n",
    "                r'hba1c[:\\s]*(\\d+\\.?\\d*)\\s*(%)?',\n",
    "                r'glycated\\s*hemoglobin[:\\s]*(\\d+\\.?\\d*)'\n",
    "            ]\n",
    "        }\n",
    "        \n",
    "        # Reference ranges\n",
    "        self.reference_ranges = {\n",
    "            'hemoglobin': {'min': 13.0, 'max': 17.0, 'unit': 'g/dL'},\n",
    "            'wbc': {'min': 4.0, 'max': 11.0, 'unit': '×10³/µL'},\n",
    "            'rbc': {'min': 4.5, 'max': 5.5, 'unit': '×10⁶/µL'},\n",
    "            'platelets': {'min': 150, 'max': 400, 'unit': '×10³/µL'},\n",
    "            'glucose': {'min': 70, 'max': 100, 'unit': 'mg/dL'},\n",
    "            'cholesterol': {'min': 0, 'max': 200, 'unit': 'mg/dL'},\n",
    "            'hdl': {'min': 40, 'max': 60, 'unit': 'mg/dL'},\n",
    "            'ldl': {'min': 0, 'max': 100, 'unit': 'mg/dL'},\n",
    "            'triglycerides': {'min': 0, 'max': 150, 'unit': 'mg/dL'},\n",
    "            'hba1c': {'min': 4.0, 'max': 5.7, 'unit': '%'}\n",
    "        }\n",
    "    \n",
    "    def clean_text(self, text):\n",
    "        \"\"\"Clean and normalize extracted text\"\"\"\n",
    "        # Convert to lowercase\n",
    "        text = text.lower()\n",
    "        \n",
    "        # Remove extra whitespace\n",
    "        text = re.sub(r'\\s+', ' ', text)\n",
    "        \n",
    "        # Remove special characters but keep important ones\n",
    "        text = re.sub(r'[^\\w\\s\\.\\-:/()×µ]', '', text)\n",
    "        \n",
    "        return text\n",
    "    \n",
    "    def extract_test_value(self, text, test_name):\n",
    "        \"\"\"\n",
    "        Extract a specific test value from text\n",
    "        \n",
    "        Args:\n",
    "            text: Cleaned text from report\n",
    "            test_name: Name of the test to extract\n",
    "            \n",
    "        Returns:\n",
    "            Extracted value as float or None\n",
    "        \"\"\"\n",
    "        patterns = self.test_patterns.get(test_name, [])\n",
    "        \n",
    "        for pattern in patterns:\n",
    "            matches = re.finditer(pattern, text, re.IGNORECASE)\n",
    "            for match in matches:\n",
    "                try:\n",
    "                    value = float(match.group(1))\n",
    "                    return value\n",
    "                except (ValueError, IndexError):\n",
    "                    continue\n",
    "        \n",
    "        return None\n",
    "    \n",
    "    def parse_report(self, text):\n",
    "        \"\"\"\n",
    "        Parse complete medical report and extract all test values\n",
    "        \n",
    "        Args:\n",
    "            text: Raw text from OCR\n",
    "            \n",
    "        Returns:\n",
    "            Dictionary with test names and values\n",
    "        \"\"\"\n",
    "        # Clean text\n",
    "        cleaned_text = self.clean_text(text)\n",
    "        \n",
    "        # Extract all test values\n",
    "        results = {}\n",
    "        for test_name in self.test_patterns.keys():\n",
    "            value = self.extract_test_value(cleaned_text, test_name)\n",
    "            if value is not None:\n",
    "                results[test_name] = {\n",
    "                    'value': value,\n",
    "                    'unit': self.reference_ranges[test_name]['unit'],\n",
    "                    'reference_min': self.reference_ranges[test_name]['min'],\n",
    "                    'reference_max': self.reference_ranges[test_name]['max'],\n",
    "                    'status': self.classify_value(test_name, value)\n",
    "                }\n",
    "        \n",
    "        return results\n",
    "    \n",
    "    def classify_value(self, test_name, value):\n",
    "        \"\"\"\n",
    "        Classify test value as normal/abnormal\n",
    "        \n",
    "        Args:\n",
    "            test_name: Name of the test\n",
    "            value: Test value\n",
    "            \n",
    "        Returns:\n",
    "            'normal', 'low', or 'high'\n",
    "        \"\"\"\n",
    "        ref = self.reference_ranges.get(test_name)\n",
    "        if not ref:\n",
    "            return 'unknown'\n",
    "        \n",
    "        if value < ref['min']:\n",
    "            return 'low'\n",
    "        elif value > ref['max']:\n",
    "            return 'high'\n",
    "        else:\n",
    "            return 'normal'\n",
    "    \n",
    "    def extract_patient_info(self, text):\n",
    "        \"\"\"\n",
    "        Extract patient information from report\n",
    "        \n",
    "        Args:\n",
    "            text: Raw text from OCR\n",
    "            \n",
    "        Returns:\n",
    "            Dictionary with patient info\n",
    "        \"\"\"\n",
    "        info = {}\n",
    "        \n",
    "        # Extract name\n",
    "        name_pattern = r'patient\\s*name[:\\s]*([a-z\\s]+)'\n",
    "        name_match = re.search(name_pattern, text, re.IGNORECASE)\n",
    "        if name_match:\n",
    "            info['name'] = name_match.group(1).strip()\n",
    "        \n",
    "        # Extract age\n",
    "        age_pattern = r'age[:\\s]*(\\d+)'\n",
    "        age_match = re.search(age_pattern, text, re.IGNORECASE)\n",
    "        if age_match:\n",
    "            info['age'] = int(age_match.group(1))\n",
    "        \n",
    "        # Extract gender\n",
    "        gender_pattern = r'gender[:\\s]*(male|female|m|f)'\n",
    "        gender_match = re.search(gender_pattern, text, re.IGNORECASE)\n",
    "        if gender_match:\n",
    "            info['gender'] = gender_match.group(1).strip()\n",
    "        \n",
    "        # Extract date\n",
    "        date_pattern = r'date[:\\s]*(\\d{1,2}[-/]\\d{1,2}[-/]\\d{2,4})'\n",
    "        date_match = re.search(date_pattern, text, re.IGNORECASE)\n",
    "        if date_match:\n",
    "            info['date'] = date_match.group(1)\n",
    "        \n",
    "        return info\n",
    "\n",
    "\n",
    "# Example usage\n",
    "if __name__ == \"__main__\":\n",
    "    # Initialize OCR\n",
    "    ocr = MedicalReportOCR()\n",
    "    parser = MedicalTextParser()\n",
    "    \n",
    "    # Example: Extract from image\n",
    "    # text = ocr.extract_text(\"sample_report.jpg\")\n",
    "    \n",
    "    # Example text (simulated OCR output)\n",
    "    sample_text = \"\"\"\n",
    "    PATIENT NAME: John Doe\n",
    "    AGE: 45 Years\n",
    "    GENDER: Male\n",
    "    DATE: 15/10/2024\n",
    "    \n",
    "    COMPLETE BLOOD COUNT (CBC)\n",
    "    \n",
    "    Hemoglobin: 12.5 g/dL (13.0 - 17.0)\n",
    "    WBC Count: 8.5 ×10³/µL (4.0 - 11.0)\n",
    "    RBC Count: 4.8 ×10⁶/µL (4.5 - 5.5)\n",
    "    Platelets: 250 ×10³/µL (150 - 400)\n",
    "    \n",
    "    BLOOD GLUCOSE\n",
    "    Fasting Blood Sugar: 110 mg/dL (70 - 100)\n",
    "    \n",
    "    LIPID PROFILE\n",
    "    Total Cholesterol: 220 mg/dL (<200)\n",
    "    HDL Cholesterol: 45 mg/dL (>40)\n",
    "    LDL Cholesterol: 140 mg/dL (<100)\n",
    "    Triglycerides: 175 mg/dL (<150)\n",
    "    \"\"\"\n",
    "    \n",
    "    # Parse report\n",
    "    patient_info = parser.extract_patient_info(sample_text)\n",
    "    test_results = parser.parse_report(sample_text)\n",
    "    \n",
    "    print(\"Patient Information:\")\n",
    "    print(patient_info)\n",
    "    print(\"\\nTest Results:\")\n",
    "    for test, data in test_results.items():\n",
    "        print(f\"{test}: {data['value']} {data['unit']} - {data['status'].upper()}\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
